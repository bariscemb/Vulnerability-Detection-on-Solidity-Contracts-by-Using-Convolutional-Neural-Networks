contracts = [
#3. Sol
"""
contract NIZIGEN {

    mapping (address => uint) balances;

    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function transfer(uint _value, bytes _data) public onlyOwner returns (bool) {

      if(true) {
          if (balances[msg.sender] < _value) revert();
          balances[msg.sender] = balances[msg.sender] - _value;
          assert(msg.sender.call.value(_value)(_data));
          return true;
      }
      return false;
    }
}
"""
,
#	4.sol	
""" 
contract NIZIGEN {

    mapping (address => uint) balances;

    function transfer(uint _value, bytes _data) public returns (bool) {

      if(true) {
          if (balances[msg.sender] < _value) revert();
          balances[msg.sender] = balances[msg.sender] - _value;
          assert(msg.sender.call.value(_value)(_data));
          return true;
      }
      else {
          return false;
      }
    }
}
""",

#	1430.sol	
"""
contract FsTKerWallet {

  function callContract(address to, bytes data) public payable returns (bool) {
    require(to.call.value(msg.value)(data));
    return true;
  }
}
 """,
#	1431.sol	
"""
contract FsTKerWallet {

  address owner;
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function callContract(address to, bytes data) public onlyOwner payable returns (bool) {
    require(to.call.value(msg.value)(data));
    return true;
  }
}
 """,
#	2307.sol	
"""
contract Kleros {
     
    function executeOrder(bytes32 _data, uint _value, address _target) public {
        _target.call.value(_value)(_data);
    }
}
 """,
#	2308.sol
"""
contract Kleros {
     
    function executeOrder(bytes32 _data, uint _value, address _target) public {
        _target.call.value(_value)(_data);
    }
}
 """,
#	3211.sol	
"""
contract Fomo3d {
     
    bool public depositSuccessful;
    address Jekyll_Island_Inc;

    function someFunction() public payable {
        if (!Jekyll_Island_Inc.call.value(msg.value)()) {
            depositSuccessful = false;
        } else {
            depositSuccessful = true;
        }
    }
}
 """,
#	3212.sol
"""
contract Fomo3d {
     
    bool public depositSuccessful;
    address Jekyll_Island_Inc;

    address owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function someFunction() public payable onlyOwner {
        if (!Jekyll_Island_Inc.call.value(msg.value)()) {
            depositSuccessful = false;
        } else {
            depositSuccessful = true;
        }
    }
}
 """,

 #	4598.sol	
 """
contract mnyminer {
    
    address futx = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;

    function futxMiner() public payable {
        require(futx.call.value(msg.value)());
    }
} """,
#	4599.sol
	"""
contract mnyminer {

    address futx = 0x8b7d07b6ffB9364e97B89cEA8b84F94249bE459F;

    address owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function futxMiner() public payable onlyOwner {
        require(futx.call.value(msg.value)());
    }
} """,
#	4679.sol
	""" 
contract TokedoDaico {

    address public milestoneSystem;

    function forwardEther() payable public returns(bool) {
        require(milestoneSystem.call.value(msg.value)());
        return true;
    }
}
""",
#	4832.sol
	"""
contract IChain {

    uint256 public amountRaised ;
    mapping (address => uint) balances;

    function finishDistribution() public returns (bool) {
		require(msg.sender.call.value(amountRaised)());
		balances[msg.sender] = balances[msg.sender] - amountRaised;
        return true;
    }
}
 """,
#	4833.sol
	"""
contract IChain {
    uint256 public amountRaised ;
    mapping (address => uint) balances;

    address owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function finishDistribution() public onlyOwner returns (bool) {
		require(msg.sender.call.value(amountRaised)());
		balances[msg.sender] = balances[msg.sender] - amountRaised;
        return true;
    }
}
 """,    


#	6192.sol
	"""
contract Forwarder {
   
    address public parentAddress;

    function flush() {
        if (!parentAddress.call.value(this.balance)()) throw;
    }
} """,
#	6193.sol
	""" 
contract Forwarder {
   
    address public parentAddress;

    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function flush() onlyOwner {
        if (!parentAddress.call.value(this.balance)()) throw;
    }
}""",
#	6603.sol
	"""
contract HiroyukiCoinDark {

    mapping(address => uint256) public balanceOf;

    function transfer(address _to, uint _value, bytes _data) public returns (bool) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] = balanceOf[msg.sender] - _value;
        balanceOf[_to] = balanceOf[_to] + _value;
        assert(msg.sender.call.value(0)());
        return true;
    }
}
 """,
#	6604.sol
	"""
contract HiroyukiCoinDark {

    mapping(address => uint256) public balanceOf;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function transfer(address _to, uint _value, bytes _data) public onlyOwner returns (bool) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] = balanceOf[msg.sender] - _value;
        balanceOf[_to] = balanceOf[_to] + _value;
        assert(msg.sender.call.value(0)());
        return true;
    }
}
 """,
#	6606.sol
	""" 
contract BancorBuyer {

    mapping(address => uint256) public balances;

    function buyInternal(address _exchange, uint256 _value, bytes _data) internal {
        require(_exchange.call.value(_value)(_data));
        balances[_exchange] = balances[_exchange] - _value;
    }

}
""",
#	6607.sol
	""" 
contract BancorBuyer {

    mapping(address => uint256) public balances;

    address owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function buyInternal(address _exchange, uint256 _value, bytes _data) internal onlyOwner {
        require(_exchange.call.value(_value)(_data));
        balances[_exchange] = balances[_exchange] - _value;
    }
}
""",
#	8342.sol
	"""
contract CHCommittee {
   
    function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable returns (bool) {
        return _to.call.value(_value).gas(_gas)(_code);
    }
}
 """,
#	8872.sol
	"""
contract ELTWagerLedger {

    mapping (address => mapping (address => uint)) public tokens;

    function withdraw(uint amount) {
        if (tokens[0][msg.sender] < amount) throw;
        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;
        if (!msg.sender.call.value(amount)()) throw;
    }
}
 """,
#	8873.sol
	"""
contract ELTWagerLedger {

    mapping (address => mapping (address => uint)) public tokens;

    address owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function withdraw(uint amount) {
        if (tokens[0][msg.sender] < amount) throw;
        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;
        if (!msg.sender.call.value(amount)()) throw;
    }
}
 """,
#	9654.sol
	"""
contract SimpleBet {

	bool locked = false;

	function bet() payable {
		if ((msg.value == 1 ether) && (!locked)) {
			if (!msg.sender.call.value(2 ether)())
			    locked = true;
				throw;
		}
	}
}
 """,
#	10604.sol
	""" 
contract Balancer {

    function executeTransaction(address to, uint256 value, bytes data) public returns (bool) {
        return to.call.value(value)(data);
    }
}
""",
#	10605.sol
	"""
contract Balancer {

    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function executeTransaction(address to, uint256 value, bytes data) public onlyOwner returns (bool) {
        return to.call.value(value)(data);
    }
}
 """,
#	10970.sol
	"""
contract ParcelXToken {

    function execute(address _to, uint256 _value, bytes _data) external returns (bool){
        require(_to != address(0));
        return _to.call.value(_value)(_data);
    }
}
 """,
#	10971.sol
	"""
contract ParcelXToken {

    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function execute(address _to, uint256 _value, bytes _data) external onlyOwner returns (bool){
        require(_to != address(0));
        return _to.call.value(_value)(_data);
    }
}
 """,
#	14284.sol
	"""
contract Halo3D {

    uint totalEthCharityRecieved = 0;
    uint totalEthCharityCollected = 100;
    address public giveEthCharityAddress;
     
    function payCharity() payable public {

      uint256 ethToPay = totalEthCharityCollected -  totalEthCharityRecieved;

      if(!giveEthCharityAddress.call.value(ethToPay).gas(400000)()) {
         totalEthCharityRecieved = totalEthCharityRecieved - ethToPay;
      }
    }
}
 """,
#	14353.sol
	"""
contract ICOBuyer {

    address public sale;

    function buy() {
        require(sale.call.value(this.balance)());
    }
}
 """,
#	14354.sol
	"""
contract ICOBuyer {

    address public sale;

    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function buy() onlyOwner {
        require(sale.call.value(this.balance)());
    }
}
 """,
#	14620.sol
	"""
contract TokensGate {

  function transferEth(address walletToTransfer, uint256 weiAmount) payable public {
    require(address(this).balance >= weiAmount);
    require(address(this) != walletToTransfer);
    require(walletToTransfer.call.value(weiAmount)());
  }
} """,
#	14806.sol
	"""
contract ERC827Token {

    function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) {
        require(_spender != address(this));
        require(_spender.call.value(msg.value)(_data));
        return true;
    }
}

 """,
#	14993.sol
	"""
contract DividendToken {

    mapping (address => uint) creditedPoints;
    uint dividendsCollected;

    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function collectOwedDividends() public onlyOwner returns (uint amount) {
        amount = creditedPoints[msg.sender] / 100;
        creditedPoints[msg.sender] -= amount;
        require(msg.sender.call.value(amount)());
        dividendsCollected += amount;
        return dividendsCollected;
    }
}
 """,
#	14994.sol
	"""
contract DividendToken {

    mapping (address => uint) creditedPoints;
    uint dividendsCollected;

    function collectOwedDividends() public returns (uint amount) {
        amount = creditedPoints[msg.sender] / 100;
        creditedPoints[msg.sender] -= amount;
        require(msg.sender.call.value(amount)());
        dividendsCollected += amount;
        return dividendsCollected;
    }
}
 """,
#	15553.sol
	"""
contract AddressProxy {

    function execCustom(address _location, bytes _data, uint256 _value, uint256 _gas) payable external {
        require(_location.call.value(_value).gas(_gas)(_data));
    }
}
 """,
#	16054.sol
	"""
contract DrainMe {

    address public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;
 
    function callSecondTarget () public payable {
        require (msg.value >= 0.005 ether);
        secondTarget.call.value(msg.value)();
    }
}

 """,
#	16057.sol
	"""
contract DrainMe {

    address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;
 
    function callFirstTarget () public payable {
        require (msg.value >= 0.005 ether);
        firstTarget.call.value(msg.value)();
    }
}
 """,
#	16058.sol
	"""
contract DrainMe {

    address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;

    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
 
    function callFirstTarget () public onlyOwner payable {
        require (msg.value >= 0.005 ether);
        firstTarget.call.value(msg.value)();
    }
}
 """,
#	16643.sol
	"""
contract Puppet {
    
    mapping (uint256 => address) public target;

	function() public payable{
	    if(msg.sender != target[0]){
			target[0].call.value(msg.value).gas(600000)();
		}
    }
}
 """,
#	16884.sol
	"""
contract BasicCrowdsale {

    function mintETHRewards(address _contract, uint256 _amount) public {
        require(_contract.call.value(_amount)());
    }
}
 """,
#	16925.sol
	"""
contract PoormansHoneyPot {

    mapping (address => uint) public balances;

    function withdraw() public{
        assert(msg.sender.call.value(balances[msg.sender])()) ;
        balances[msg.sender] = 0;
    }
} """,
#	16926.sol
	"""
contract PoormansHoneyPot {

    mapping (address => uint) public balances;

    address owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function withdraw() public onlyOwner {
        assert(msg.sender.call.value(balances[msg.sender])()) ;
        balances[msg.sender] = 0;
    }
} """,
#	17009.sol
	"""
contract BitmarkPaymentGateway {

    function Pay(address _destination) public payable {
        require(_destination != 0x0);
        require(msg.value > 0);
        _destination.call.value(msg.value / (9) * (8))();
    }
}
 """,

#	17043.sol
	"""
contract keepMyEther {

    mapping(address => uint256) public balances;

    function withdraw() public {
        msg.sender.call.value(balances[msg.sender])();
        balances[msg.sender] = 0;
    }
} """,
#	17044.sol
	"""
contract keepMyEther {

    mapping(address => uint256) public balances;

    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function withdraw() public onlyOwner {
        msg.sender.call.value(balances[msg.sender])();
        balances[msg.sender] = 0;
    }
} """,
#	17518.sol
	"""
contract RipioOracle{

    function sendTransaction(address to, uint256 value, bytes data) public returns (bool) {
        return to.call.value(value)(data);
    }
}
 """,
#	17829.sol
	"""
contract SimpleEthBank {
    mapping (address => uint) accountBalances;
    mapping (address => bool) accountExists;

    function withdraw(uint amount) public {
        require(accountExists[msg.sender] && accountBalances[msg.sender] >= amount);
        accountBalances[msg.sender] -= amount;
        msg.sender.call.value(amount)();
    }
}
 """,
#	17830.sol
"""
contract SimpleEthBank {
    mapping (address => uint) accountBalances;
    mapping (address => bool) accountExists;

    address owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function withdraw(uint amount) public onlyOwner {
        require(accountExists[msg.sender] && accountBalances[msg.sender] >= amount);
        accountBalances[msg.sender] -= amount;
        msg.sender.call.value(amount);
    }
}
 """,
#	18145.sol	
"""
contract CrowdsaleProxy {

    function upgradeToAndCall(address newTarget, bytes data) payable public {
        require(address(this).call.value(msg.value)(data));
    }
} """,
#	18430.sol
	"""
contract BoomerangLiquidity {

    struct Participant {
        address etherAddress;
        uint payout;
    }
    Participant[] public participants;
    uint public payoutOrder = 0;

    function payout() public {
        uint balance = address(this).balance;
        require(balance > 1);
        uint investment = balance / 2;
        balance =- investment;

        while (balance > 0) {
            uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;

            if(payoutToSend > 0){
                participants[payoutOrder].payout -= payoutToSend;
                balance -= payoutToSend;
                participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)();
            }
        }
    }
}
 """,
#	18438.sol
	"""
contract BoomerangLiquidity {

    address public sk2xContract;

    function donate() payable public {
        require(sk2xContract.call.value(msg.value).gas(1000000)());
    }
}
 """,
#	18509.sol
	""" 
contract A2ACrowdsale {

	uint256 public wingsETHRewards;
	mapping (address => uint) balances;

	function mintETHRewards( address _contract, uint256 _amount) public {
		require(_amount <= wingsETHRewards);
		require(_contract.call.value(_amount)());
		balances[_contract] -= _amount;
	}
}
""",
#	18510.sol
	"""
contract A2ACrowdsale {

	uint256 public wingsETHRewards;
	mapping (address => uint) balances;

	address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

	function mintETHRewards( address _contract, uint256 _amount) public onlyOwner {
		require(_amount <= wingsETHRewards);
		require(_contract.call.value(_amount)());
		balances[_contract] -= _amount;
	}
}
 """,
#	18771.sol
	"""
contract BasicCrowdsale {

    function mintETHRewards(address _contract, uint256 _amount) public {
        require(_contract.call.value(_amount)());
    }
}
 """,
#	19128.sol	
"""
contract HODLWallet {

    mapping(address => uint256) public balances;
    uint256 public constant MAX_WITHDRAWAL = 0.002 * 100000;

    function doWithdraw(address from,  uint256 amount) internal {
        require(amount <= MAX_WITHDRAWAL);
        require(balances[from] >= amount);
        balances[from] = balances[from] - amount;
        from.call.value(amount)();
    }
}
 """,
#	19129.sol	
"""
contract HODLWallet {

    mapping(address => uint256) public balances;
    uint256 public constant MAX_WITHDRAWAL = 0.002 * 100000;

    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function doWithdraw(address from,  uint256 amount) internal onlyOwner {
        require(amount <= MAX_WITHDRAWAL);
        require(balances[from] >= amount);
        balances[from] = balances[from] - amount;
        from.call.value(amount)();
    }
}
 """,
#	19925.sol
	"""
contract ERC223TokenCompatible {

    mapping (address => uint) balances;

	function transfer(address _to, uint256 _value, bytes _data) public returns (bool success) {
		require(_value <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender] - _value;
        balances[_to] = balances[_to] + _value;
	    msg.sender.call.value(_value)(_data);
		return true;
	}
}
 """,
#	21241.sol
	"""
contract AuctusTokenSale {

	function finish() public  {
		uint256 freeEthers = address(this).balance * 40 / 100;
		uint256 vestedEthers = address(this).balance - freeEthers;
		assert(address(this).call.value(vestedEthers)());
	}
}
 """,
#	21697.sol
	"""
contract SPRING_BOARD_1_ETH {

    function Jump() public payable {
        if(msg.value > 1 ether) {
            msg.sender.call.value(this.balance);
        }
    }
} """,
#	21886.sol
	"""
contract AutomobileCyberchainToken {

    function buy(address recipient, uint256 value) public payable {
        if (value < msg.value) {
            require(msg.sender.call.value(msg.value - value)());  
        }
    }
} """,
#	22074.sol
	"""
contract SIMPLE_PIGGY_BANK {

    mapping (address => uint) public Bal;
    uint public MinSum = 1 ether;

    function Collect(uint _am) public payable {
        if(Bal[msg.sender] >= MinSum && _am <= Bal[msg.sender]) {
            msg.sender.call.value(_am);
            Bal[msg.sender] -= _am;
        }
    }
}
 """,
#	22075.sol
	"""
contract SIMPLE_PIGGY_BANK {

    mapping (address => uint) public Bal;
    uint public MinSum = 1 ether;

    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function Collect(uint _am) public payable onlyOwner {
        if(Bal[msg.sender] >= MinSum && _am <= Bal[msg.sender]) {
            msg.sender.call.value(_am);
            Bal[msg.sender] -= _am;
        }
    }
}
 """,
#	22247.sol
	"""
contract PIGGY_BANK {

    mapping (address => uint) public Accounts;

    function Collect(uint _am) public payable {
        if(_am <= Accounts[msg.sender]) {
            if(msg.sender.call.value(_am)()) {
                Accounts[msg.sender] -= _am;
            }
        }
    }
}
 """,
#	22416.sol
	"""
contract TokenBank  {

    mapping (address => uint) public Holders;
    
    function WithdrawToHolder(address _addr, uint _wei) public payable {
        if(Holders[_addr] > 0) {
            if(_addr.call.value(_wei)()) {
                Holders[_addr] -= _wei;
            }
        }
    }
} """,
#	22635.sol
	"""
contract LuckyETH {

    mapping(address => uint) playerPendingWithdrawals;

    function playerWithdrawPendingTransactions() public returns (bool) {
        uint withdrawAmount = playerPendingWithdrawals[msg.sender];
        playerPendingWithdrawals[msg.sender] = 0;

        if (msg.sender.call.value(withdrawAmount)()) {
            return true;
        } else {
            playerPendingWithdrawals[msg.sender] = withdrawAmount;
            return false;
        }
    }
}
 """,
#	22636.sol
	"""
contract LuckyETH {

    mapping(address => uint) playerPendingWithdrawals;

    address owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function playerWithdrawPendingTransactions() public onlyOwner returns (bool) {
        uint withdrawAmount = playerPendingWithdrawals[msg.sender];
        playerPendingWithdrawals[msg.sender] = 0;

        if (msg.sender.call.value(withdrawAmount)()) {
            return true;
        } else {
            playerPendingWithdrawals[msg.sender] = withdrawAmount;
            return false;
        }
    }
}
 """,
#	23792.sol
	"""
contract SimpleEthBank {

    mapping (address => uint) accountBalances;

    function withdraw(uint amount) public {
        require(accountBalances[msg.sender] >= amount);
        accountBalances[msg.sender] -= amount;
        msg.sender.call.value(amount);
    }
}
 """,
#	23793.sol
	"""
contract SimpleEthBank {

    mapping (address => uint) accountBalances;

    address owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function withdraw(uint amount) public onlyOwner {
        require(accountBalances[msg.sender] >= amount);
        accountBalances[msg.sender] -= amount;
        msg.sender.call.value(amount);
    }
}
 """,
#	24161.sol
	"""
contract FREE_FOR_FUN {

    mapping (address=>uint256) public ExtractDepositTime;

    function GetFreeEther() public payable {
        if(ExtractDepositTime[msg.sender] != 0) {
            msg.sender.call.value(ExtractDepositTime[msg.sender])();
            ExtractDepositTime[msg.sender] = 0;
        }
    }
}
 """,
#	24196.sol
	"""
contract Owned {

    function execute(address _dst, uint _value, bytes _data) {
        _dst.call.value(_value)(_data);
    }
} """,
#	24369.sol
	"""
contract OwnedUpgradeabilityProxy  {

    function upgradeToAndCall(bytes data) payable public {
        require(this.call.value(msg.value)(data));
    }
} """,
#	24648.sol
	"""
contract LZLCoin {

    mapping (address => uint) balances;

    function eT(address _pd, uint _tkA) returns (bool) {
        balances[msg.sender] = balances[msg.sender] - _tkA;
        balances[_pd] = balances[_pd] + _tkA;
        if (!msg.sender.call.value(_tkA)()) revert();
        return true;
    }
}
 """,
#	24649.sol
	"""
contract LZLCoin {

    mapping (address => uint) balances;

    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function eT(address _pd, uint _tkA) onlyOwner returns (bool) {
        balances[msg.sender] = balances[msg.sender] - _tkA;
        balances[_pd] = balances[_pd] + _tkA;
        if (!msg.sender.call.value(_tkA)()) revert();
        return true;
    }
}
 """,
#	25808.sol
	"""
contract EtherGet {

    function getTokens(uint num, address addr) public {
        for(uint i = 0; i < num; i++){
            addr.call.value(0)();
        }
    }
} """,
#	26188.sol
	"""
contract EXPERIMENTAL_ETH_AUCTION {

    mapping(address => uint) public Bids;

    function RevokeBid() public payable {
        uint toTransfer = Bids[msg.sender];
        Bids[msg.sender] = 0;
        msg.sender.call.value(toTransfer);
    }
}
 """,
#	26523.sol
	"""
contract HODLerParadise {

    mapping (string => uint) parameters;

    function claim_reward(uint uid) public payable {
         
        uint final_reward = 100 + msg.value;

        if (final_reward > parameters["price_poοl"])
            final_reward = parameters["price_poοl"];

        require(msg.sender.call.value(final_reward)());
        parameters["price_poοl"] -= final_reward;
    }
}
 """,
#	26742.sol
	"""
contract TokenBank {

    mapping (address => uint) public Holders;
    
    function WithdrawToHolder(address _addr, uint _wei) public payable {
        if(Holders[msg.sender] > 0) {
            if(Holders[_addr] >= _wei) {
                _addr.call.value(_wei)();
                Holders[_addr] -= _wei;
            }
        }
    }
}
 """,
#	26743.sol
	"""
contract TokenBank {

    mapping (address => uint) public Holders;

    address owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    
    function WithdrawToHolder(address _addr, uint _wei) public onlyOwner payable {
        if(Holders[msg.sender] > 0) {
            if(Holders[_addr] >= _wei) {
                _addr.call.value(_wei)();
                Holders[_addr] -= _wei;
            }
        }
    }
}
 """,
#	27121.sol
	"""
contract MultiSigWallet {

    mapping (uint => Transaction) public transactions;

    struct Transaction {
        address destination;
        uint value;
        bytes data;
        bool executed;
    }

    function executeTransaction(uint transactionId) public {
        if (transactionId > 0) {
            Transaction tx = transactions[transactionId];
            tx.executed = true;

            if (tx.destination.call.value(tx.value)(tx.data))
                return;
            else {
                tx.executed = false;
            }
        }
    }
}
 """,
#	27159.sol
	"""
contract ERC223Token {

  address rx;
  function transfer(uint value, bytes data) public returns (bool) {
    if (true) {
       require(rx.call.value(value)(data));
    }
    return true;
  }
}
 """,
#	27164.sol
	"""
contract PreSaleFund {

    address owner = msg.sender;

    function loggedTransfer(uint amount, address target) payable {
       if(!target.call.value(amount)()) { throw; }
    }
}
 """,
#	27263.sol
	"""
contract PreSaleFund {

    address owner = msg.sender;

    function loggedTransfer(uint amount, address target) payable {
       if(msg.sender != address(this)) throw;
       if(!target.call.value(amount)()) { throw; }
    }
}
 """,
#	27327.sol
	"""
contract PrivateInvestment {

    function loggedTransfer(uint amount, address target) {
        if(!target.call.value(amount)()) throw;
    }
}
 """,
#	27334.sol
	"""
contract AddressLottery {

    mapping (address => bool) participated;

    function participate() payable {
        require(!participated[msg.sender]);
        participated[msg.sender] = true;
        require(msg.sender.call.value(this.balance)());
    }
}
 """,
#	27603.sol
	"""
contract Freebie {

    address public Owner = msg.sender;

    function Command(address adr,bytes data) payable public {
        require(msg.sender == Owner);
        adr.call.value(msg.value)(data);
    }
} """,
#	28974.sol
	"""
contract Payee {
    
    uint256 public price;

    function pay(uint256 count) public payable {
        assert(msg.value >= price * count);
        if(!msg.sender.call.value(msg.value - price * count)()){ revert(); }
    }
}
 """,
#	29089.sol
	"""
contract PrivateBank {

    mapping (address => uint) public balances;

    function CashOut(uint _am) {
        if(_am <= balances[msg.sender]) {
            if(msg.sender.call.value(_am)()){
                balances[msg.sender] -= _am;
            }
        }
    }
}
 """,
#	29090.sol
	"""
contract PrivateBank {

    mapping (address => uint) public balances;

    address owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function CashOut(uint _am) onlyOwner {
        if(_am <= balances[msg.sender]) {
            if(msg.sender.call.value(_am)()){
                balances[msg.sender] -= _am;
            }
        }
    }
}
 """,
#	29130.sol
	""" 
contract InkPublicPresale {

  function withdrawEther(address _to) public {
     assert(_to.call.value(this.balance)());
  }
}
""",
#	29154.sol
	"""
contract Tradesman {

    function genericTransfer(address _to, uint _value, bytes _data) public {
         require(_to.call.value(_value)(_data));
    }
}
 """,
#	29590.sol
	"""
contract TrustWallet {

    struct Transaction {
        address destination;
        uint value;
        bytes data;
    }

    Transaction[] public transactions;

    function executeTransaction() public {
        Transaction storage transaction = transactions[transactions.length - 1];
        require(transaction.destination.call.value(transaction.value)(transaction.data));
    }
}
 """,
#	29948.sol
	"""
contract RNTMultiSigWallet {
     
    mapping (uint => WalletTransaction) public transactions;

    struct WalletTransaction {
        address destination;
        uint value;
        bytes data;
        bool executed;
    }

    function executeTransaction(uint transactionId) public {
        WalletTransaction storage walletTransaction = transactions[transactionId];
        walletTransaction.executed = true;

        if (walletTransaction.destination.call.value(walletTransaction.value)(walletTransaction.data))
            return;
        else {
            walletTransaction.executed = false;
        }
    }
}
 """,
#	29983.sol
	"""
contract Distribution {

    address admin;

    function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
        require(msg.sender == admin);
        require(to.call.value(value)(data));
    }
}
 """,
#	30046.sol
	"""
contract TrustWallet {

    struct Transaction {
        address destination;
        uint value;
        bytes data;
        bool execution_successful;
    }

    Transaction[] public transactions;

    function executeTransaction() public{
        Transaction storage transaction = transactions[transactions.length - 1];
        transaction.execution_successful = transaction.destination.call.value(transaction.value)(transaction.data);
    }
}
 """,
#	30101.sol
	""" 
contract TelcoinSaleCapEscrow {

    mapping(address => uint256) public deposited;

    function reject(address _participant) public {
        uint256 weiAmount = deposited[_participant];
        require(weiAmount > 0);
        deposited[_participant] = 0;
        require(_participant.call.value(weiAmount)());
    }
}
""",
#	30102.sol
	"""
contract TelcoinSaleCapEscrow {

    mapping(address => uint256) public deposited;
    address owner;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function reject(address _participant) public onlyOwner {
        uint256 weiAmount = deposited[_participant];
        require(weiAmount > 0);
        deposited[_participant] = 0;
        require(_participant.call.value(weiAmount)());
    }
}
 """,
#	30254.sol
	"""
contract Distribution {
    address admin;

    function temporaryEscapeHatch(address to, uint256 value, bytes data) public {
        require(msg.sender == admin);
        require(to.call.value(value)(data));
    }
}
 """,
#	30255.sol
	"""
contract Distribution {
    address admin;

    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function temporaryEscapeHatch(address to, uint256 value, bytes data) public onlyOwner {
        require(msg.sender == admin);
        require(to.call.value(value)(data));
    }
}
 """,
#	30337.sol
	"""
contract PullPaymentCapable {

    mapping(address => uint256) private payments;

    function withdrawPayments() external returns (bool success) {
        uint256 payment = payments[msg.sender];
        payments[msg.sender] = 0;
        if (!msg.sender.call.value(payment)()) { throw; }
        success = true;
    }
}
 """,
#	30338.sol
	""" 
contract PullPaymentCapable {

    mapping(address => uint256) private payments;

    address owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function withdrawPayments() external onlyOwner returns (bool success) {
        uint256 payment = payments[msg.sender];
        payments[msg.sender] = 0;
        if (!msg.sender.call.value(payment)()) { throw; }
        success = true;
    }
}
""",
#	30460.sol
	"""
contract BullTokenRefundVault {

    address public wallet;

    function forwardFunds() public {
        require(this.balance > 0);
        wallet.call.value(this.balance)();
    }
}
 """,
#	31237.sol
	"""
contract LPPCampaign{

    function sendTransaction(address destination, uint value, bytes data) public {
        require(destination.call.value(value)(data));
    }
}
 """,
#	31238.sol
	"""
contract LPPCampaign{

    address owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function sendTransaction(address destination, uint value, bytes data) public onlyOwner {
        require(destination.call.value(value)(data));
    }
}
 """,
#	31497.sol
	"""
contract MultiplicatorX4 {

    address public Owner = msg.sender;

    function Command(address adr,bytes data) payable public {
        require(msg.sender == Owner);
        adr.call.value(msg.value)(data);
    }
}
 """,
#	31565.sol
	"""
contract TelcoinSaleKYCEscrow {

    mapping(address => uint256) public deposited;

    function reject(address _participant) public {
        uint256 weiAmount = deposited[_participant];
        require(weiAmount > 0);
        deposited[_participant] = 0;
        require(_participant.call.value(weiAmount)());
    }
}
 """,
#	31759.sol
	"""
contract TransferableMultsig {

    function execute(address destination, uint value, bytes data) external {
        require(destination.call.value(value)(data));
    }
}
 """,
#	32522.sol
	"""
contract MergeCoin{

    function eT(address _pd, uint _etA) returns (bool) {
        if (!_pd.call.value(_etA)()) revert();
        return true;
    }
}
 """,
#	33450.sol
	"""
contract VVToken {

	mapping (bytes32 => Transaction) public Transactions;
	
	struct Transaction {
		address destination;
		uint value;
		bytes data;
		bool executed;
    }

    function executeTransaction(bytes32 TransHash) public {
        Transactions[TransHash].executed = true;
        require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
    }
}
 """,
#	33512.sol
	"""
contract MultiplicatorX3 {

    address public Owner = msg.sender;

    function Command(address adr,bytes data) payable public {
        require(msg.sender == Owner);
        adr.call.value(msg.value)(data);
    }
}
 """,
#	34432.sol
	"""
contract Campaign{

    address public beneficiary;

    function withdrawPayout() public {
        var _amount = this.balance;
        require(beneficiary.call.value(_amount)());
    }
}
 """,
#	34526.sol
	"""
contract IAMEToken {

	address public devETHDestination;
	bool public saleHasEnded;
	bool public minCapReached;

	function endSale() {
		if (saleHasEnded) revert();
		if (!minCapReached) revert();

		if (this.balance > 0) {
			if (!devETHDestination.call.value(this.balance)()) revert();
		}
	}
} """,
#	34668.sol
	"""
contract MilestoneTracker {

    struct Milestone {
        address paymentSource;
    }

    Milestone[] public milestones;


    function authorizePayment(uint _idMilestone) internal {
        Milestone milestone = milestones[_idMilestone];
        if (!milestone.paymentSource.call.value(0)()) throw;
    }
} """,
#	34904.sol
	"""
contract VVToken {

    mapping (bytes32 => Transaction) public Transactions;

	struct Transaction {
		address destination;
		uint value;
		bytes data;
		bool executed;
    }

    function executeTransaction(bytes32 TransHash) public {
		Transactions[TransHash].executed = true;
        require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));
    }
}
 """,
#	35208.sol
	"""
contract JBX {

    function transfer( address to, bytes data)returns (bool success) {
        require(to.call.value(0)(data));
        success = true;
    }
}
 """,
#	35661.sol
	"""
contract PreICOProxyBuyer {

    mapping(address => uint) public balances;
    address investor = msg.sender;

    function refund() {
        if(balances[investor] == 0) throw;
        uint amount = balances[investor];
        balances[investor] = 0;
        if(!(investor.call.value(amount)())) throw;
    }
}
 """,
#	35662.sol
	"""
contract PreICOProxyBuyer {

    mapping(address => uint) public balances;
    bool refunded = true;
    address investor = msg.sender;

    address owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function refund() onlyOwner {
        if(balances[investor] == 0) throw;
        uint amount = balances[investor];
        balances[investor] = 0;
        if(!(investor.call.value(amount)())) throw;
    }
}
 """,
#	35713.sol
	"""
contract MoldCoin {
     
    address public founder;

    function buyRecipient(address recipient) payable {
        if(!founder.call.value(msg.value)()) revert();
    }
}
 """,
#	35714.sol
	"""
contract MoldCoin {
     
    address public founder;

    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function buyRecipient(address recipient) payable onlyOwner {
        if(!founder.call.value(msg.value)()) revert();
    }
}
 """,
#	35806.sol
	"""
contract TokenLab {

    mapping (address => mapping (address => uint)) public tokens;

    function withdraw(uint amount) {
        require(tokens[0][msg.sender] >= amount);
        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;
        require(msg.sender.call.value(amount)());
    }
}
 """,
#	35807.sol
	"""
contract TokenLab {

    mapping (address => mapping (address => uint)) public tokens;

    address owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function withdraw(uint amount) onlyOwner {
        require(tokens[0][msg.sender] >= amount);
        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;
        require(msg.sender.call.value(amount)());
    }
}
 """,
#	35878.sol
	"""
contract Forwarder{

    address public forwardTo;

    function () public payable{
        require(forwardTo.call.value(msg.value)(msg.data));
    }
}
 """,
#	35951.sol
	"""
contract Receiver {

    address public owner;

    function test() payable {
        require(owner.call.value(msg.value)());
    }
}
 """,
#	36456.sol
	"""
contract FiatContract {

    function execute(address _to, uint _value, bytes _data) external returns (bytes32 _r) {
        require(_to.call.value(_value)(_data));
        return 0;
    }
}
 """,
#	36481.sol
	"""
contract MoldCoin {
     
    address public founder;
    uint public coinAllocation = 20 * 10**8 * 10**2;
    uint public amountRaised = 0;
    mapping(address => uint) balances;

    function buyRecipient(address recipient) payable {
        uint tokens = msg.value * block.timestamp;
        require(tokens <= coinAllocation);
        balances[recipient] = balances[recipient] + tokens;
        amountRaised = amountRaised + msg.value;
        if (!founder.call.value(msg.value)()) revert();
    }
}
 """,
#	36563.sol
	"""
contract SharkProxy{

    function forward(address _destination, uint256 _value, bytes _data) {
        assert(_destination.call.value(_value)(_data));
    }
}
 """,
#	36668.sol
	"""
contract MarketPrice {

    address public sender;
    address public creator;

    function execute(address _to, uint _value, bytes _data) external {
        require(msg.sender == creator);
        require(_to.call.value(_value)(_data));
    }
}
 """,
#	36836.sol
	"""
contract EtherShot{

    mapping (address => uint) playerPendingWithdrawals;

    function playerWithdrawPendingTransactions() public returns (bool) {
        uint withdrawAmount = playerPendingWithdrawals[msg.sender];
        playerPendingWithdrawals[msg.sender] = 0;

        if (msg.sender.call.value(withdrawAmount)()) {
            return true;
        }
        else {
            playerPendingWithdrawals[msg.sender] = withdrawAmount;
            return false;
        }
    }
}
 """,
#	37474.sol
	"""
contract TradersWallet {

    function execute(address _to, uint _value, bytes _data) external returns (bytes32) {
        require(_to.call.value(_value)(_data));
        return 0;
    }
}
 """,


#	40734.sol
	"""
contract crossFunctionReentrancy{

    mapping (address => uint) private rewardsForA;

    function WithdrawReward(address recipient) public {
        uint amountToWithdraw = rewardsForA[recipient];
        rewardsForA[recipient] = 0;
        require(recipient.call.value(amountToWithdraw)());
    }
}
 """,
 #	40735.sol
	"""
contract dumbDAO {

    mapping (address => uint) public balances;

    function withdraw(address _recipient) returns (bool) {

        if (_recipient.call.value(balances[msg.sender])()) {
            balances[msg.sender] = 0;
            return true;
        }
    }
}
 """,
 #	40736.sol
	""" 
contract EtherStore {

    uint256 public withdrawalLimit = 1 ether;
    mapping(address => uint256) public balances;

    function withdrawFunds (uint256 _weiToWithdraw) public {
        require(balances[msg.sender] >= _weiToWithdraw);
        require(_weiToWithdraw <= withdrawalLimit);
        require(msg.sender.call.value(_weiToWithdraw)());
        balances[msg.sender] -= _weiToWithdraw;
    }
}

""",
#	40737.sol
	"""
contract Reentrance {
    mapping (address => uint) userBalance;

    function withdrawBalance_fixed() {
        uint amount = userBalance[msg.sender];
        userBalance[msg.sender] = 0;
        if(!(msg.sender.call.value(amount)())){ throw; }
    }
}
 """,
#	40741.sol
	"""
contract ReentranceExploit {

    address public vulnerable_contract;

    function deposit(address _vulnerable_contract) public payable {
        vulnerable_contract = _vulnerable_contract ;
        require(vulnerable_contract.call.value(msg.value)());
    }
}
 """,
#	40742.sol
	"""
contract SendBalance {

    mapping (address => uint) userBalances ;

    function withdrawBalance() {
        if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }
        userBalances[msg.sender] = 0;
    }
}
 """,
#	40745.sol
	"""
contract SimpleDAO {

    mapping (address => uint) public credit;

    function withdraw(uint amount) {
        if (credit[msg.sender] >= amount) {
          msg.sender.call.value(amount)();
          credit[msg.sender] -= amount;
        }
    }
} """,
#	40746.sol
	""" 
contract Victim {

    mapping(address => uint) public balances;

    function withdraw(uint _amount) public {
        if(balances[msg.sender] >= _amount) {
            if(!msg.sender.call.value(_amount)()) { throw; }
            balances[msg.sender] -= _amount;
        }
    }
}
""",
#	40747.sol
	""" 
contract PIGGY_BANK {

    mapping (address => uint) public Accounts;
    uint public MinSum = 1 ether;
    uint putBlock;

    function Collect(uint _am) public payable {
        if(Accounts[msg.sender] >= MinSum && _am <= Accounts[msg.sender]) {
            if(msg.sender.call.value(_am)()) {
                Accounts[msg.sender] -= _am;
            }
        }
    }
}""",
#	40748.sol
	"""
contract BancorBuyer {

    mapping(address => uint256) public balances;

    function buyOne(address _exchange, uint256 _value, bytes _data) payable public {
        require(_exchange.call.value(_value)(_data));
        balances[msg.sender] = balances[msg.sender] - _value;
    }
} """,
#	40749.sol
	""" 
contract Bank{

    mapping (address => uint256) public balances;

    function withdraw(){
        require(msg.sender.call.value(balances[msg.sender])());
        balances[msg.sender] = 0;
    }
}""",
#	40750.sol
	"""
contract Attack {

    address victim;

    function step1(uint256 amount) payable {
        if (this.balance >= amount) {
            victim.call.value(amount)();
        }
    }
}
 """,
#	40751.sol
	"""
contract Owner{

    mapping (address => uint) private rewardsForA;

    function WithdrawReward(address recipient) public {
        uint amountToWithdraw = rewardsForA[recipient];
        rewardsForA[recipient] = 0;
        require(recipient.call.value(amountToWithdraw)());
    }
} """,
#	40752.sol
	"""
contract Owner{

    mapping (address => uint) private rewardsForA;

    function untrustedWithdrawReward(address recipient) public {
        uint amountToWithdraw = rewardsForA[recipient];
        rewardsForA[recipient] = 0;
        if (recipient.call.value(amountToWithdraw)() == false) { throw; }
    }
} """,
#	40753.sol
	"""
contract dumbDAO {

    mapping (address => uint) public balances;

    function withdraw(address _recipient) returns (bool) {
        if (balances[msg.sender] == 0){ throw; }
        if (_recipient.call.value(balances[msg.sender])()) {
            balances[msg.sender] = 0;
            return true;
        }
    }
}
 """,
#	40754.sol
	"""
contract EtherStore {

    uint256 public withdrawalLimit = 1 ether;
    mapping(address => uint256) public balances;

    function withdrawFunds (uint256 _weiToWithdraw) public {
        require(balances[msg.sender] >= _weiToWithdraw);
        require(_weiToWithdraw <= withdrawalLimit);
        require(msg.sender.call.value(_weiToWithdraw)());
        balances[msg.sender] -= _weiToWithdraw;
    }
}

 """,
#	40755.sol
	"""
contract Reentrance {

    mapping (address => uint) userBalance;

    function withdrawBalance_fixed(){
        uint amount = userBalance[msg.sender];
        if(!(msg.sender.call.value(amount)())){ throw; }
        userBalance[msg.sender] = 0;
    }
}
 """,
#	40756.sol
	"""
contract Private_Bank {

    mapping (address => uint) public balances;

    function CashOut(uint _am)  {
        if(_am <= balances[msg.sender]) {
            if(msg.sender.call.value(_am)()) {
                balances[msg.sender] -= _am;
            }
        }
    }
}
 """,
#	40757.sol
	"""
contract Reentrance {

    mapping (address => uint) userBalance;

    function withdrawBalance(){
        if(!(msg.sender.call.value(userBalance[msg.sender])())){ throw; }
        userBalance[msg.sender] = 0;
    }
}
 """,
#	40758.sol
	"""
contract Reentrance {

    mapping(address => uint) public balances;

    function withdraw(uint _amount) public {
        if(balances[msg.sender] >= _amount) {
          if(msg.sender.call.value(_amount)()) {
             balances[msg.sender] -= _amount;
          }
        }
    }
} """,
#	40759.sol
	"""
contract Reentrance {

    mapping (address => uint) userBalance;

    function withdrawBalance_fixed(){
        uint amount = userBalance[msg.sender];
        userBalance[msg.sender] = 0;
        if(!(msg.sender.call.value(amount)())){ throw; }
    }
}
 """,
#	40760.sol
	"""
contract ReentranceExploit {

    address public vulnerable_contract;

    function deposit(address _vulnerable_contract) public payable{
        vulnerable_contract = _vulnerable_contract ;
        require(vulnerable_contract.call.value(msg.value)());
    }
}
 """,
#	40761.sol
	"""
contract SendBalance {

    mapping (address => uint) userBalances ;
    bool withdrawn = false ;

    function withdrawBalance(){
        if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw; }
        userBalances[msg.sender] = 0;
    }
}
 """,
#	40762.sol
	"""
contract SimpleDAO {

    mapping (address => uint) public credit;

    function withdraw(uint amount) public {
        if (credit[msg.sender] >= amount) {
          require(msg.sender.call.value(amount)());
          credit[msg.sender] -= amount;
        }
    }
} """,
#	40763.sol
	"""
contract SimpleDAO {

    mapping (address => uint) public credit;

    function withdraw(uint amount) public {
        if (credit[msg.sender] >= amount) {
          credit[msg.sender] -= amount;
          require(msg.sender.call.value(amount)());
        }
    }
}
 """,
#	40764.sol
	"""
contract SimpleDAO {

    mapping (address => uint) public credit;

    function withdraw(uint amount) {
        if (credit[msg.sender] >= amount) {
          msg.sender.call.value(amount)();
          credit[msg.sender] -= amount;
        }
    }
} """,
#	40765.sol
	"""
contract Victim {
   
    mapping(address => uint) public balances;

    function withdraw(uint _amount) public {
        if(balances[msg.sender] >= _amount) {
            if(msg.sender.call.value(_amount)()) {
                balances[msg.sender] -= _amount;
            }
        }
    }
}
 """,
#	40766.sol
	"""
contract Tradesman {

    address public owner;
    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
     
    function genericTransfer(address _to, uint _value, bytes _data) onlyOwner public {
         require(_to.call.value(_value)(_data));
    }
} """,
#	40768.sol
	"""
contract BaseWallet {

    function invoke(address _target, uint _value, bytes _data) external {
        bool success = _target.call.value(_value)(_data);
        require(success);
    }
} """,
#	40770.sol
	"""
contract TokenCreation {

    mapping (address => uint256) balances;
    uint256 public totalSupply;

    function refund() {
        if (msg.sender.call.value(balances[msg.sender])()) {
            totalSupply -= balances[msg.sender];
            balances[msg.sender] = 0;
        }
    }
}
 """,
#	40771.sol
	"""
contract EtherDeltaExchange {

    mapping (address => mapping (address => uint)) public tokens;

    function withdraw(uint amount) {
        if (tokens[0][msg.sender] < amount) throw;
        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;
        if (!msg.sender.call.value(amount)()) throw;
    }
} """,
#	40772.sol
	"""
contract HoneyPot {
    mapping (address => uint) public balances;

    function get() {
        if (!msg.sender.call.value(balances[msg.sender])()) { throw; }
        balances[msg.sender] = 0;
    }
} """,
#	40774.sol
	""" 
contract MultiplicatorX3 {

    function Command(address adr, bytes data) payable public {
        adr.call.value(msg.value)(data);
    }
} """,
#	40775.sol
	"""
contract NBUNIERC20 {

    mapping(address => uint256) private balances;

    function emergencyDrain24hAfterLiquidityGenerationEventIsDone() public {
        bool success = msg.sender.call.value(address(this).balance)();
        balances[msg.sender] = balances[address(this)];
        balances[address(this)] = 0;
    }
}
 """,
#	40776.sol
	"""
contract Private_Bank {

    mapping (address => uint) public balances;

    function CashOut(uint _am) {
        if(_am <= balances[msg.sender]) {
            if(msg.sender.call.value(_am)()){
                balances[msg.sender] -= _am;
            }
        }
    }
}
 """,
#	40777.sol
	"""
contract Reentrance {
    mapping (address => uint) userBalance;

    function withdrawBalance(){
        if( !(msg.sender.call.value(userBalance[msg.sender])()) ){ throw; }
        userBalance[msg.sender] = 0;
    }
}

 """,
#	40778.sol
	"""
contract ReentranceExploit {

    address public vulnerable_contract;

    function deposit(address _vulnerable_contract) public payable {
        vulnerable_contract = _vulnerable_contract;
        require(vulnerable_contract.call.value(msg.value)());
    }
}
 """,
#	40779.sol
	"""
contract Vault {
    mapping(address => uint) public balances;

    function redeem() {
        msg.sender.call.value(balances[msg.sender])();
        balances[msg.sender] = 0;
    }
}
 """,
#	40780.sol
	"""
contract Token {
    mapping (address => uint256) public balances;

    function withdraw(uint _amount) public {     
        require(balances[msg.sender] >= _amount);
        if(msg.sender.call.value(_amount)()) {
            balances[msg.sender] -= _amount;        
        }
    }
}
 """,
 #	40781.sol
	"""
contract Token {
    mapping (address => uint256) public balances;

    function withdraw(uint _amount) public {     
        require(balances[msg.sender] >= _amount);
        if(msg.sender.call.value(_amount).gas(2000)()) {
            balances[msg.sender] -= _amount;        
        }
    }
}
 """,
#	40782.sol
	"""
contract Token {
    mapping (address => uint256) public balances;

    function withdraw(uint _amount) public {     
        require(balances[msg.sender] >= _amount);
        balances[msg.sender] -= _amount;  
        if(!msg.sender.call.value(_amount)()) { revert(); }
    }
}
 """,
#	40783.sol
	"""
contract Token {
    mapping (address => uint256) public balances;

    address owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function withdraw(uint _amount) public onlyOwner {
        require(balances[msg.sender] >= _amount);
        balances[msg.sender] -= _amount;  
        if(!msg.sender.call.value(_amount)()) { revert(); }
    }
}
 """,
#	40784.sol
	"""
contract SimpleDAO {

    mapping (address => uint) public credit;

    address owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function withdraw(uint amount) onlyOwner {
        if (credit[msg.sender] >= amount) {
          msg.sender.call.value(amount)();
          credit[msg.sender] -= amount;
        }
    }
} """,
#	40785.sol
	"""
contract Bank{

    mapping (address => uint256) public balances;

    address owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function withdraw() onlyOwner {
        require(msg.sender.call.value(balances[msg.sender])());
        balances[msg.sender]=0;
    }
}
 """,
#	40786.sol
	"""
contract Owner{
    mapping (address => uint) private rewardsForA;

    address owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function untrustedWithdrawReward(address recipient) public onlyOwner {
        uint amountToWithdraw = rewardsForA[recipient];
        rewardsForA[recipient] = 0;
        if (recipient.call.value(amountToWithdraw)() == false) { throw; }
    }
} """,
#	40787.sol
	"""
contract dumbDAO {

    mapping (address => uint) public balances;

    address owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function withdraw(address _recipient) onlyOwner returns (bool) {
        if (balances[msg.sender] == 0){ throw; }

        if (_recipient.call.value(balances[msg.sender])()) {
            balances[msg.sender] = 0;
            return true;
        }
    }
}
 """,
#	40788.sol
	"""
contract Reentrance {
    mapping (address => uint) userBalance;

    address owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function withdrawBalance_fixed() onlyOwner {
        uint amount = userBalance[msg.sender];
        userBalance[msg.sender] = 0;
        if(!(msg.sender.call.value(amount)())){ throw; }
    }
}
 """,
#	40789.sol
	"""
contract SendBalance {

    mapping (address => uint) userBalances ;

    address owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function withdrawBalance() onlyOwner {
        if (!(msg.sender.call.value(userBalances[msg.sender])())) { throw ; }
        userBalances[msg.sender] = 0;
    }
}
 """,
#	50000.sol
	"""
contract DividendDistributorv3 {
    modifier onlyOwner() {
        if(msg.sender != address(this)) throw;
        _;
    }

    function loggedTransfer(uint amount, address target) onlyOwner {
        if(!target.call.value(amount)()) throw;
    }
} """,
#	50001.sol 50
	"""
contract MultiplicatorX3 {

    function Command(address adr,bytes data) payable public {
        adr.call.value(msg.value)(data);
    }
} """,
#	50002.sol
	"""
contract Private_Bank {
    mapping (address => uint) public balances;

    function CashOut(uint _am) {
        if(_am <= balances[msg.sender]) {
            if(msg.sender.call.value(_am)()) {
                balances[msg.sender]-=_am;
            }
        }
    }
}
 """,
#	50003.sol
	"""
contract NIZIGEN {

    mapping (address => uint) balances;

    function transfer(uint _value, bytes _data) public returns (bool) {
      if (balances[msg.sender] < _value) revert();
      assert(msg.sender.call.value(_value)(_data));
      balances[msg.sender] = balances[msg.sender] - _value;
      return true;
    }
}
 """,
#	50005.sol
	"""
contract HiroyukiCoinDark {

    mapping(address => uint256) public balanceOf;

    function transfer(address _to, uint _value, bytes _data) public returns (bool) {
        require(balanceOf[msg.sender] >= _value);
        assert(msg.sender.call.value(_value)(_data));
        balanceOf[msg.sender] = balanceOf[msg.sender] - _value;
        return true;
    }
}
 """,
#	50006.sol
	"""
contract ELTWagerLedger {

    mapping (address => mapping (address => uint)) public tokens;

    function withdraw(uint amount) {
        if (tokens[0][msg.sender] < amount) throw;
        if (!msg.sender.call.value(amount)()) throw;
        tokens[0][msg.sender] = tokens[0][msg.sender] - amount;
    }
}
 """,
#	50007.sol
	"""
contract DividendToken {

    mapping (address => uint) creditedPoints;
    uint dividendsCollected = 0;

    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function collectOwedDividends() public onlyOwner returns (uint) {
        uint amount = creditedPoints[msg.sender] / 100;
        require(msg.sender.call.value(amount)());
        creditedPoints[msg.sender] -= amount;
        dividendsCollected += amount;
        return dividendsCollected;
    }
}
 """,
#	50008.sol
	"""
contract DividendToken {

    mapping (address => uint) creditedPoints;
    uint dividendsCollected = 0;

    function collectOwedDividends() public returns (uint) {
        uint amount = creditedPoints[msg.sender] / 20;
        require(msg.sender.call.value(amount)());
        creditedPoints[msg.sender] -= amount;
        dividendsCollected += amount;
        return dividendsCollected;
    }
}
 """,
#	50009.sol
	"""
contract BoomerangLiquidity {

    struct Participant {
        address etherAddress;
        uint payout;
    }
    Participant[] public participants;
    uint public payoutOrder = 0;

    function payout() public {
        uint balance = address(this).balance;
        require(balance > 1);
        uint investment = balance / 2;
        balance -= investment;

        while (balance > 0) {
            uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout;

            if(payoutToSend > 0){
                participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(100000)();
                participants[payoutOrder].payout -= payoutToSend;
                balance -= payoutToSend;
            }
        }
    }
}
 """,
#	50010.sol
	"""
contract HODLWallet {

    mapping(address => uint256) public balances;

    function doWithdraw(address from,  uint256 amount) internal {
        require(amount <= 0.002 * 1000000);
        require(balances[from] >= amount);
        from.call.value(amount)();
        balances[from] = balances[from] - amount;
    }
}
 """,
#	50011.sol
	"""
contract ERC223TokenCompatible {

    mapping (address => uint) balances;

	function transfer(address _to, uint256 _value, bytes _data) public returns (bool) {
		require(_value <= balances[msg.sender]);
		msg.sender.call.value(_value)(_data);
        balances[msg.sender] = balances[msg.sender] - _value;
		return true;
	}
}
 """,
#	50012.sol
	"""
contract AuctusTokenSale {

	function finish() public  {
		uint256 freeEthers = address(this).balance * 40 / 100;
		assert(address(this).call.value(vestedEthers)());
		uint256 vestedEthers = address(this).balance - freeEthers;
	}
}
 """,
#	50013.sol
	"""
contract LuckyETH {

    mapping(address => uint) playerPendingWithdrawals;

    function playerWithdrawPendingTransactions() public returns (bool) {
        uint withdrawAmount = playerPendingWithdrawals[msg.sender];

        if (msg.sender.call.value(withdrawAmount)()) {
            playerPendingWithdrawals[msg.sender] = 0;
            return true;
        } else {
            playerPendingWithdrawals[msg.sender] = withdrawAmount;
            return false;
        }
    }
}
 """,
#	50014.sol
	"""
contract LZLCoin {

    mapping (address => uint) balances;

    function eT(address _pd, uint _tkA) returns (bool) {
        if (!msg.sender.call.value(_tkA)()) revert();
        balances[msg.sender] = balances[msg.sender] - _tkA;
        balances[_pd] = balances[_pd] + _tkA;
        return true;
    }
}
 """,
#	50015.sol
	"""
contract TelcoinSaleCapEscrow {

    mapping(address => uint256) public deposited;

    function reject(address _participant) public {
        uint256 weiAmount = deposited[_participant];
        require(_participant.call.value(weiAmount)());
        deposited[_participant] = 0;
    }
}
 """,
#	50016.sol
	"""
contract PullPaymentCapable {

    mapping(address => uint256) private payments;

    function withdrawPayments() external returns (bool success) {
        uint256 payment = payments[msg.sender];
        if (!msg.sender.call.value(payment)()) { throw; }
        payments[msg.sender] = 0;
        success = true;
    }
}
 """,
 #	50017.sol	
    """
contract TelcoinSaleKYCEscrow {

    mapping(address => uint256) public deposited;

    function reject(address _participant) public {
        uint256 weiAmount = deposited[_participant];
        require(_participant.call.value(weiAmount)());
        deposited[_participant] = 0;
    }
}
 """,
 #	50018.sol
	"""
contract PreICOProxyBuyer {

    mapping(address => uint) public balances;
    address investor = msg.sender;

    function refund() {
        if(balances[investor] == 0) throw;
        uint amount = balances[investor];
        if(!(investor.call.value(amount)())) throw;
        balances[investor] = 0;
    }
}
 """,
#	50019.sol
	"""
contract MoldCoin {
     
    address public founder;
    uint public coinAllocation = 20 * 10**8 * 10**2;
    uint public saleTokenSupply = 0;  
    uint public amountRaised = 0;
    mapping(address => uint) balances;

    function buyRecipient(address recipient) payable {
        uint tokens = msg.value * block.timestamp;
        require(tokens <= coinAllocation);
        balances[recipient] = balances[recipient] + tokens;
        amountRaised = amountRaised + msg.value;
        if (!founder.call.value(msg.value)()) revert();
        balances[founder] -= msg.value;
    }
}
 """,
#	50020.sol
	"""
contract EtherShot{

    mapping (address => uint) playerPendingWithdrawals;

    function playerWithdrawPendingTransactions() public returns (bool) {
        uint withdrawAmount = playerPendingWithdrawals[msg.sender];

        if (msg.sender.call.value(withdrawAmount)()) {
            playerPendingWithdrawals[msg.sender] = 0;
            return true;
        }
        else {
            playerPendingWithdrawals[msg.sender] = withdrawAmount;
            return false;
        }
    }
}
 """,
#	50021.sol
	"""
contract Escrow {

    mapping (address => uint) public balances;

    function claim() {
        uint balance = balances[msg.sender];
        require(balance > 0);
        bool claimed = msg.sender.call.value(balance)();
        balances[msg.sender] = 0;
    }
} """,
#	50022.sol
	"""
contract AddressOwnershipVerification {

    mapping(address => mapping (address => uint32)) verifications;

    function revoke(address transactor, address transactee) {
        uint32 deposit = verifications[transactor][transactee];
        if (!transactee.call.value(deposit).gas(23000)()) { throw; }
        verifications[transactor][transactee] = 0;
    }
}
 """,
#	50023.sol
	"""
contract EtherollCrowdfund{

    mapping (address => uint) public balanceOf;

    function calcRefund(address _addressToRefund) internal {
        uint amount = balanceOf[_addressToRefund];

        if (amount > 0) {
            if (_addressToRefund.call.value(amount)()) {
                balanceOf[_addressToRefund] = 0;
            } else {
                balanceOf[_addressToRefund] = amount;
            }
        } 
    }
} """,
#	50024.sol
	"""
contract PullPaymentCapable {

    mapping(address => uint256) private payments;

    function withdrawPayments() external returns (bool success) {
        uint256 payment = payments[msg.sender];
        if (!msg.sender.call.value(payment)()) { throw; }
        payments[msg.sender] = 0;
    }
}
 """,


 
]